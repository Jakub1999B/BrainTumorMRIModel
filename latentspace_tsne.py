# -*- coding: utf-8 -*-
"""latentspace_tsne.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AkXczd4KbqyaG5MvLEji7EI7D2QanTtl
"""

import os
import sys
sys.path.append("/content/drive/MyDrive/BrainTumorMRIModel")
import numpy as np
import pandas as pd
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow import keras
from skimage import color
from skimage import io
import sklearn
from tqdm import tqdm
import cv2
import seaborn as sns
from keras import layers
from sklearn.model_selection import train_test_split
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras import datasets, layers, models
from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report
import argparse
from tensorflow.keras.utils import to_categorical
from imutils import paths
from tensorflow.keras.optimizers import SGD
from keras import Sequential
from sklearn import manifold
import glob2
from matplotlib.offsetbox import OffsetImage, AnnotationBbox

def embedding(dataset,model):
  embedded = []
  classes = []

  for x_batch, y_batch in dataset:
    embed = model.get_embedding(x_batch)
    embed = np.array(embed)
    embedded.append(embed)
    classes.append(y_batch)

  x_embedding = np.concatenate(embedded, axis=0)

  y = np.concatenate(classes, axis=0)
  y = y.astype(int)

  y_tsne = []

  for i in y:
    index = 0
    for j in i:
      if j == 1:
        y_tsne.append(index)
      index += 1

  return x_embedding, y_tsne

# scale and move the coordinates so they fit [0; 1] range

def scale_to_01_range(x):
    # compute the distribution range
    value_range = (np.max(x) - np.min(x))
    # move the distribution so that it starts from zero
    # by extracting the minimal value from all its values
    starts_from_zero = x - np.min(x)
    # make the distribution fit [0; 1] by dividing by its range
    return starts_from_zero / value_range

def t_sne(x, y_tsne):
    tsne = manifold.TSNE(n_components=2,init='pca')
    transformed = tsne.fit_transform(x)

    tx = transformed[:, 0]
    ty = transformed[:, 1]

    tx = scale_to_01_range(tx)
    ty = scale_to_01_range(ty)

    # create dataframe
    tsne_df = pd.DataFrame(columns=['t-SNE1', 't-SNE2', 'labels'],
                          data=np.column_stack((tx, ty, 
                                                y_tsne)))
    # cast targets column to int
    tsne_df.loc[:, 'labels'] = tsne_df.labels.astype(int)
    tsne_df.head()

    labels_map = {0:'Glioma tumor',
                1: 'Meningioma tumor',
                2: 'No tumor',
                3: 'Pituitary tumor'}
    # map targets to actual clothes for plotting
    tsne_df.loc[:, 'labels'] = tsne_df.labels.map(labels_map)

    return tx, ty, tsne_df

def getImage(path):
  x = plt.imread(path)
  res = cv2.resize(x, dsize=(40,40), interpolation=cv2.INTER_CUBIC)
  return OffsetImage(res)

def viz_tsne(tsne_df):
    plt.figure(figsize=(20,20))
    plot = sns.jointplot(data = tsne_df, x = 't-SNE1', y='t-SNE2', hue='labels', height=16, xlim = (-0.1, 1.1), ylim=(-0.1, 1.1), s = 90)
    plot.ax_marg_x.set_xlim(-0.1, 1.1)
    plot.ax_marg_y.set_ylim(-0.1, 1.1)
    plt.show()

def viz_tsne_img(tx,ty,image_names):
    fig, ax = plt.subplots(figsize=(15,15))
    ax.scatter(tx,ty)
    ax.set_ylabel('t-SNE2')
    ax.set_xlabel('t-SNE1')
    for x0, y0, path in zip(tx,ty,image_names):
      ab = AnnotationBbox(getImage(path),(x0,y0),frameon = False)
      ax.add_artist(ab)